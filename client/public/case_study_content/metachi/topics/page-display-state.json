{
  "title": "Page Display State Service",
  "description": "During the process of building a new feature, I realized that I needed a more well tailored approach to parsing the url and using that to drive the appearance of the page. By tying the page state to a standardized object, it becomes much easier to conditionally render html or other subcomponents, especially as a feature becomes more complex. The implications for improving user experience are great, as users can navigate easily within components by using the built in back/forward functionality of the browser. This is especially relevant for mobile users who are used to swiping back and forth to navigate web pages.",
  "tabs": [
    {
      "title": "Service",
      "description": "The service is made up of two classes: the Angular service, and the UrlHandler class.  The Angular service only handles Angular specific stuff such as getting and parsing the url, instantiating the UrlHandler class, and passing off the new url to the UrlHandler as it changes. Separating the logic into two classes made a lot of sense from an object oriented perspective; easier testing, easier to read, and potential for reuse of the UrlHandler class in a different setting if necessary.",
      "code": "export interface Effect<T> {\n    matcher: string[];\n    cb: StatefulCallback<T>;\n}\n\nexport type StatefulCallback<T> = (url: string[]) => T;\nexport type StatelessCallback = (url?: string[]) => void;\n\n@Injectable({\n    providedIn: 'root'\n})\nexport class PageStateFromUrlService {\n    private urlHandler: UrlHandler<any>;\n    private baseRoute: string;\n\n    constructor(private router: Router) {\n    }\n\n    public register = <T>(\n        defaultState: T,\n        effects: Effect<T>[],\n        statelessEffects?: StatelessCallback[]\n    ): Observable<T> => {\n        this.baseRoute = this.getBaseRoute();\n        this.urlHandler = new UrlHandler<T>(defaultState, effects, statelessEffects);\n        return this.getUrlSegments$().pipe(map(this.urlHandler.handleUrl));\n    }\n\n    protected getBaseRoute = () => this.splitUrl(this.router.routerState.snapshot.url)[2];\n\n    protected getUrlSegments$ = () => this.getUrlFromEvents$().pipe(\n        map((c: string) => this.splitUrl(c)),\n        map((url) => this.getChildRoutes(url)),\n    )\n\n    protected getUrlFromEvents$ = () => this.router.events.pipe(\n        filter((e) => e instanceof NavigationEnd),\n        map((e) => (e as NavigationEnd).url),\n        startWith(this.router.routerState.snapshot.url),\n    )\n\n    protected splitUrl = (url: string): string[] => url.split('/');\n\n    protected getChildRoutes = (url: string[]): string[] => {\n        try {\n            return url.slice(url.indexOf(this.baseRoute) + 1);\n        } catch {\n            return [''];\n        }\n    }\n}"
    },
    {
      "title": "Class",
      "description": "The UrlHandler class is the workhorse of the service. It provides all of the url matching functionality, and will call callback functions originating from the angular component. There are two types of callback functions: those that return a state object and are only called when the url matches a specific pattern, and those that return nothing and are called every time the url changes.",
      "code": "export class UrlHandler<T> {\n    private effects: Effect<T>[] = [];\n    private statelessEffects: StatelessCallback[] = [];\n    private readonly defaultState: T;\n\n    constructor(defaultState: T, effects: Effect<T>[], statelessEffects?: StatelessCallback[]) {\n        this.defaultState = defaultState;\n        this.statelessEffects = statelessEffects || [];\n        this.effects = this.sortWildcardEffectsLast(effects);\n    }\n\n    protected sortWildcardEffectsLast = (effects: Effect<T>[]) =>\n        [...effects.filter((e) => e.matcher.indexOf('*') < 0), ...effects.filter((e) => e.matcher.indexOf('*') >= 0)]\n\n    public handleUrl = (urls: string[]) => this.applyEffects(urls);\n\n    protected applyEffects = (url: string[]): T => {\n        let state: T;\n        this.applyStatelessEffects(url);\n        this.effects.forEach((e) => {\n            if (this.matches(e.matcher, url)) {\n                state = state ? state : e.cb(url);\n            }\n        });\n        return state || this.defaultState;\n    }\n\n    protected applyStatelessEffects = (url: string[]) => this.statelessEffects.forEach((cb) => cb(url));\n\n    protected matches = (matcher: string[], url: string[]): boolean => {\n        if (matcher.length === 0 || matcher.length !== url.length) {\n            return false;\n        }\n        let match = true;\n        matcher.forEach((m, i) => {\n            match = match ? url[i] === m || m === '*' : false;\n        });\n        return match;\n    }\n}"
    },
    {
      "title": "Usage",
      "description": "One of my main aims for this service was to reduce complexity as much as possible when writing a component that conditionally renders ui. For simple components it will often suffice to use a boolean flag for this purpose, but once things get more complicated with multiple flags or more than two options for rendering one part of the ui, it’s easy to end up with spaghetti code. Luckily, an unambiguous state object, such as an enum, can be just the ticket to straighten things out.",
      "code": "enum UiState {\n    DEFAULT = 'default',\n    STATE1 = 'state1',\n    STATE2 = 'state2',\n}\n\n@Component({\n    template: `\n        <ng-container *ngIf=\"currentState$ | async as state else error\">\n            <p *ngIf=\"state === uiState.DEFAULT\">Default Display</p>\n            <p *ngIf=\"state === uiState.STATE1\">State 1</p>\n            <p *ngIf=\"state === uiState.STATE2\">State 2</p>\n        </ng-container>\n        <ng-template #error>\n            <p>Whoops</p>\n        </ng-template>\n    `\n})\nexport class ExampleComponent implements OnInit {\n    uiState = UiState;\n    currentState$: Observable<UiState>;\n\n    constructor(private stateService: PageStateFromUrlService) {\n    }\n\n    ngOnInit() {\n        this.currentState$ = this.stateService.register(\n            UiState.DEFAULT,\n            [\n                {matcher: ['route'], cb: this.statefulEffect},\n                {matcher: ['route', '*'], cb: () => UiState.STATE2},\n            ],\n            [\n                this.statelessEffect,\n            ]);\n    }\n\n    statefulEffect = (urls: string[]) => {\n        console.log(urls);\n        return UiState.STATE1;\n    }\n\n    statelessEffect = () => console.log('url changed')\n}\n"
    },
    {
      "title": "Test",
      "description": "Below are some unit tests that cover the more important features of the UrlHandler. It’s always nice for my sanity to be able to run tests and bask in the glow of the green check marks after doing a minor refactor or feature add.",
      "code": "describe('url handler', () => {\n\n    it('should construct', () => {\n        const handler = new UrlHandler('', [], []);\n        expect(handler).toBeTruthy();\n    });\n\n    it('should match urls', () => {\n        const urlSegment = Randomizer.nextString();\n        const resultingState = Randomizer.nextString();\n        const callback = () => resultingState;\n        const effect: Effect<string> = {matcher: [urlSegment], cb: callback};\n        const effectWithWildcard: Effect<string> = {matcher: ['*'], cb: callback};\n        const handler = new UrlHandler('', [effect, effectWithWildcard]);\n\n        const resultWithExactMatch = handler.handleUrl([urlSegment]);\n        const resultWithWildcard = handler.handleUrl([Randomizer.nextString()]);\n\n        expect(resultWithExactMatch).toEqual(resultingState);\n        expect(resultWithWildcard).toEqual(resultingState);\n    });\n\n    it('should try to match wildcards after callbacks with exact matchers', () => {\n        const urlSegment = Randomizer.nextString();\n        let exactMatcherEffectCalled = false;\n        let wildcardMatcherEffectCalled = false;\n        const exactMatcherCallback = () => {\n            exactMatcherEffectCalled = true;\n            expect(wildcardMatcherEffectCalled).toBe(false);\n        };\n        const wildCardMatcherCallback = () => {\n            wildcardMatcherEffectCalled = true;\n            expect(exactMatcherEffectCalled).toBe(true);\n        };\n        const effectWithExactMatch: Effect<unknown> = {matcher: [urlSegment], cb: exactMatcherCallback};\n        const effectWithWildcard: Effect<unknown> = {matcher: ['*'], cb: wildCardMatcherCallback};\n\n        const handler = new UrlHandler('', [effectWithWildcard, effectWithExactMatch]);\n\n        handler.handleUrl([urlSegment]);\n        handler.handleUrl([Randomizer.nextString()]);\n\n        expect(exactMatcherEffectCalled).toBe(true);\n        expect(wildcardMatcherEffectCalled).toBe(true);\n    });\n\n    it('should return default state if no matchers match', () => {\n        const defaultState = Randomizer.nextString();\n        const handler = new UrlHandler(defaultState, []);\n        const resultWithNoMatch = handler.handleUrl([Randomizer.nextString()]);\n\n        expect(resultWithNoMatch).toEqual(defaultState);\n    });\n\n    it('should call stateless callbacks before the state changes', () => {\n        let statelessCallbackCalled = false;\n        let effectCalled = false;\n        const statelessCallback: StatelessCallback = () => {\n            statelessCallbackCalled = true;\n            expect(effectCalled).toBe(false);\n        };\n        const effect: Effect<unknown> = {matcher: ['*'], cb: () => {\n            effectCalled = true;\n            expect(statelessCallbackCalled).toBe(true);\n            }};\n        const handler = new UrlHandler('', [effect], [statelessCallback]);\n\n        handler.handleUrl([Randomizer.nextString()]);\n        expect(statelessCallbackCalled).toBe(true);\n        expect(effectCalled).toBe(true);\n    });\n});"
    }
  ]
}