{
  "title": "Typescript Ui Logic: Page Display State Service",
  "description": "During the process of building a new feature, I realized that I needed a more well tailored approach to parsing the url and using that to drive the appearance of the page. In order to do this, I created an Angular service that would use a set of callback functions to perform some side effects and return an object representing the page state. The service pipes an observable originating from the router service through the callback functions before returning it for the component to subscribe to.",
  "tabs": [
    {
      "title": "Service",
      "description": "The Angular service itself only handles getting the   application's url, which it parses before handing off to a new instance of the UrlHandler class, along with callbacks provided by the component that is using the service. By having the Angular service only deal with parsing the url and interfacing with Angular components, it would be very easy to extract the functionality provided to a non-Angular setting.",
      "code": "export interface Effect<T> {\n    matcher: string[];\n    cb: StatefulCallback<T>;\n}\n\nexport type StatefulCallback<T> = (url: string[]) => T;\nexport type StatelessCallback = (url?: string[]) => void;\n\n@Injectable({\n    providedIn: 'root'\n})\nexport class PageStateFromUrlService {\n    private urlHandler: UrlHandler<any>;\n    private baseRoute: string;\n\n    constructor(private router: Router) {\n    }\n\n    public register = <T>(\n        defaultState: T,\n        effects: Effect<T>[],\n        statelessEffects?: StatelessCallback[]\n    ): Observable<T> => {\n        this.baseRoute = this.getBaseRoute();\n        this.urlHandler = new UrlHandler<T>(defaultState, effects, statelessEffects);\n        return this.getUrlSegments$().pipe(map(this.urlHandler.handleUrl));\n    }\n\n    protected getBaseRoute = () => this.splitUrl(this.router.routerState.snapshot.url)[2];\n\n    protected getUrlSegments$ = () => this.getUrlFromEvents$().pipe(\n        map((c: string) => this.splitUrl(c)),\n        map((url) => this.getChildRoutes(url)),\n    )\n\n    protected getUrlFromEvents$ = () => this.router.events.pipe(\n        filter((e) => e instanceof NavigationEnd),\n        map((e) => (e as NavigationEnd).url),\n        startWith(this.router.routerState.snapshot.url),\n    )\n\n    protected splitUrl = (url: string): string[] => url.split('/');\n\n    protected getChildRoutes = (url: string[]): string[] => {\n        try {\n            return url.slice(url.indexOf(this.baseRoute) + 1);\n        } catch {\n            return [''];\n        }\n    }\n}"
    },
    {
      "title": "Class",
      "description": "This class is the workhorse of the service. It provides all of the url matching functionality, and will call callback functions whose return values are then emitted through the state observable. There are also callback functions which do not return anything, stateless effects, that are called every time the url changes. If no match is found, the default state will be emitted. The class returns the value of the first matching stateful callback that is found, so wildcard matchers are handled last.",
      "code": "export class UrlHandler<T> {\n    private effects: Effect<T>[] = [];\n    private statelessEffects: StatelessCallback[] = [];\n    private readonly defaultState: T;\n\n    constructor(defaultState: T, effects: Effect<T>[], statelessEffects?: StatelessCallback[]) {\n        this.defaultState = defaultState;\n        this.statelessEffects = statelessEffects || [];\n        this.effects = this.sortWildcardEffectsLast(effects);\n    }\n\n    protected sortWildcardEffectsLast = (effects: Effect<T>[]) =>\n        [...effects.filter((e) => e.matcher.indexOf('*') < 0), ...effects.filter((e) => e.matcher.indexOf('*') >= 0)]\n\n    public handleUrl = (urls: string[]) => this.applyEffects(urls);\n\n    protected applyEffects = (url: string[]): T => {\n        let state: T;\n        this.applyStatelessEffect(url);\n        this.effects.forEach((e) => {\n            if (this.matches(e.matcher, url)) {\n                state = state ? state : (e.cb as StatefulCallback<T>)(url);\n            }\n        });\n        return state || this.defaultState;\n    }\n\n    protected applyStatelessEffect = (url: string[]) => this.statelessEffects.forEach((cb) => cb(url));\n\n    protected matches = (matcher: string[], url: string[]): boolean => {\n        if (matcher.length === 0 || matcher.length !== url.length) {\n            return false;\n        }\n        let match = true;\n        matcher.forEach((m, i) => {\n            match = match ? url[i] === m || m === '*' : false;\n        });\n        return match;\n    }\n}"
    },
    {
      "title": "Usage",
      "description": "By tying the page state to a standardized object, it becomes much easier to conditionally render html or other subcomponents, especially as a feature becomes more complex. The implications for improving user experience are great, as users can navigate easily within components by using the built in back/forward functionality of the browser. This is especially relevant for mobile users who are used to swiping back and forth to navigate web pages.",
      "code": "enum UiState {\n    DEFAULT = 'default',\n    STATE1 = 'state1',\n    STATE2 = 'state2',\n}\n\n@Component({\n    template: `\n        <ng-container *ngIf=\"currentState$ | async as state else error\">\n            <p *ngIf=\"state === uiState.DEFAULT\">Default Display</p>\n            <p *ngIf=\"state === uiState.STATE1\">State 1</p>\n            <p *ngIf=\"state === uiState.STATE2\">State 2</p>\n        </ng-container>\n        <ng-template #error>\n            <p>Whoops</p>\n        </ng-template>\n    `\n})\nexport class ExampleComponent implements OnInit {\n    uiState = UiState;\n    currentState$: Observable<UiState>;\n\n    constructor(private stateService: PageStateFromUrlService) {\n    }\n\n    ngOnInit() {\n        this.handleUrl();\n    }\n\n    handleUrl = () => {\n        this.currentState$ = this.stateService.register(\n            UiState.DEFAULT,\n            [\n                {matcher: ['route'], cb: this.statefulEffect},\n                {matcher: ['route', '*'], cb: () => UiState.STATE2},\n            ],\n            [\n                this.statelessEffect,\n            ]);\n    }\n\n    statefulEffect = (urls: string[]) => {\n        console.log(urls);\n        return UiState.STATE1;\n    }\n\n    statelessEffect = () => console.log('url changed')\n}\n"
    },
    {
      "title": "Test",
      "description": "Some unit tests for the UrlHandler class",
      "code": "describe('url handler', () => {\n\n    it('should construct', () => {\n        const handler = new UrlHandler('', [], []);\n        expect(handler).toBeTruthy();\n    });\n\n    it('should match urls', () => {\n        const urlSegment = Randomizer.nextString();\n        const resultingState = Randomizer.nextString();\n        const callback = () => resultingState;\n        const effect: Effect<string> = {matcher: [urlSegment], cb: callback};\n        const effectWithWildcard: Effect<string> = {matcher: ['*'], cb: callback};\n        const handler = new UrlHandler('', [effect, effectWithWildcard]);\n\n        const resultWithExactMatch = handler.handleUrl([urlSegment]);\n        const resultWithWildcard = handler.handleUrl([Randomizer.nextString()]);\n\n        expect(resultWithExactMatch).toEqual(resultingState);\n        expect(resultWithWildcard).toEqual(resultingState);\n    });\n\n    it('should try to match wildcards after callbacks with exact matchers', () => {\n        const urlSegment = Randomizer.nextString();\n        let exactMatcherEffectCalled = false;\n        let wildcardMatcherEffectCalled = false;\n        const exactMatcherCallback = () => {\n            exactMatcherEffectCalled = true;\n            expect(wildcardMatcherEffectCalled).toBe(false);\n        };\n        const wildCardMatcherCallback = () => {\n            wildcardMatcherEffectCalled = true;\n            expect(exactMatcherEffectCalled).toBe(true);\n        };\n        const effectWithExactMatch: Effect<unknown> = {matcher: [urlSegment], cb: exactMatcherCallback};\n        const effectWithWildcard: Effect<unknown> = {matcher: ['*'], cb: wildCardMatcherCallback};\n\n        const handler = new UrlHandler('', [effectWithWildcard, effectWithExactMatch]);\n\n        handler.handleUrl([urlSegment]);\n        handler.handleUrl([Randomizer.nextString()]);\n\n        expect(exactMatcherEffectCalled).toBe(true);\n        expect(wildcardMatcherEffectCalled).toBe(true);\n    });\n\n    it('should return default state if no matchers match', () => {\n        const defaultState = Randomizer.nextString();\n        const handler = new UrlHandler(defaultState, []);\n        const resultWithNoMatch = handler.handleUrl([Randomizer.nextString()]);\n\n        expect(resultWithNoMatch).toEqual(defaultState);\n    });\n\n    it('should call stateless callbacks before the state changes', () => {\n        let statelessCallbackCalled = false;\n        let effectCalled = false;\n        const statelessCallback: StatelessCallback = () => {\n            statelessCallbackCalled = true;\n            expect(effectCalled).toBe(false);\n        };\n        const effect: Effect<unknown> = {matcher: ['*'], cb: () => {\n            effectCalled = true;\n            expect(statelessCallbackCalled).toBe(true);\n            }};\n        const handler = new UrlHandler('', [effect], [statelessCallback]);\n\n        handler.handleUrl([Randomizer.nextString()]);\n        expect(statelessCallbackCalled).toBe(true);\n        expect(effectCalled).toBe(true);\n    });\n});"
    }
  ]
}