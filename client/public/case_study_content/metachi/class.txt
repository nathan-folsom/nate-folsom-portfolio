class UrlHandler<T> {
    private urls$: Observable<string[]>;
    private effects: Effect<T>[] = [];
    private statelessEffects: StatelessCallback[] = [];
    private readonly defaultState: T;

    constructor(urls$: Observable<string[]>, defaultState: T, effects: Effect<T>[], statelessEffects?: StatelessCallback[]) {
        this.urls$ = urls$;
        this.defaultState = defaultState;
        this.statelessEffects = statelessEffects || [];
        this.effects = this.putWildcardEffectsLast(effects);
    }

    protected putWildcardEffectsLast = (effects: Effect<T>[]) =>
        [...effects.filter((e) => e.matcher.indexOf('*') < 0), ...effects.filter((e) => e.matcher.indexOf('*') >= 0)]

    public getState$ = () => this.urls$.pipe(
        map((url) => this.applyEffects(url))
    )

    protected applyEffects = (url: string[]): T => {
        let state: T;
        this.applyStatelessEffect(url);
        this.effects.forEach((e) => {
            if (this.matches(e.matcher, url)) {
                state = state ? state : (e.cb as StatefulCallback<T>)(url);
            }
        });
        return state || this.defaultState;
    }

    protected applyStatelessEffect = (url: string[]) => this.statelessEffects.forEach((cb) => cb(url));

    protected matches = (matcher: string[], url: string[]): boolean => {
        if (matcher.length === 0 || matcher.length !== url.length) {
            return false;
        }
        let match = true;
        matcher.forEach((m, i) => {
            match = match ? url[i] === m || m === '*' : false;
        });
        return match;
    }
}