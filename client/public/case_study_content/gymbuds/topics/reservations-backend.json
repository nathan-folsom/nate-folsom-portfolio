{
  "title": "Reservation System Backend",
  "description": "The core functionality of Gymbuds revolves around storing information about gym reservations that its users are making. These reservations are then resurfaced to both the users who created them, and their friends. While the basic system for dealing with reservations doesnâ€™t need to be too complicated, it should be robust and well tested. Its main components are a service that handles database transactions with some help from Prisma, and a GraphQL resolver that performs authentication on each request before handing things off to the service.",
  "tabs": [
    {
      "title": "Service",
      "description": "",
      "code": "@Injectable()\nexport class ReservationService {\n    constructor(private db: PrismaService,\n                private reservationAdaptor: ReservationAdaptor) {\n    }\n\n    createReservation = async (input: CreateReservationInput, userId: string): Promise<Reservation> => {\n        const {time, location, message} = input;\n        const reservation = await this.db.reservationEntity.create({\n            data: {\n                time, location, message, userId\n            }\n        })\n        return this.reservationAdaptor.toGql(reservation);\n    }\n\n    deleteReservation = (id: string) => this.db.reservationEntity.delete({\n        where: {\n            id\n        }\n    })\n\n    getUpcomingReservationsForUserId = (userId: string) => this.db.reservationEntity.findMany({\n        where: {\n            userId,\n            time: {gte: new Date()}\n        }\n    })\n\n    getAllReservationsForUserId = async (userId: string): Promise<Reservation[]> => {\n        const friends = await this.db.friendEntity.findMany({where: {userId}});\n        const friendIds = friends.map(e => e.userId);\n        const allIds = [ ...friendIds, userId ];\n        const allReservations = await Promise.all(allIds.map(id => this.getUpcomingReservationsForUserId(id)));\n        const flattened = this.flattenReservations(allReservations);\n        return this.reservationAdaptor.toGqls(flattened);\n    }\n\n    private flattenReservations = (all: ReservationEntity[][]): ReservationEntity[] => {\n        let reservations = [];\n        all.forEach(item => {\n            reservations = reservations.concat(item);\n        })\n        return reservations;\n    }\n\n    getById = (id: string) => this.db.reservationEntity.findUnique({\n        where: {\n            id\n        }\n    })\n}"
    },
    {
      "title": "Resolver",
      "description": "",
      "code": "@Resolver('Reservation')\nexport class ReservationResolver {\n    constructor(private reservationService: ReservationService) {\n    }\n\n    @Query('myReservations')\n    async reservationsCreatedByUser(@Context('authToken', GetUserPipe) userPromise: Promise<User>) {\n        const user = await userPromise;\n        if (user) {\n            return this.reservationService.getUpcomingReservationsForUserId(user.userId);\n        }\n        return [];\n    }\n\n    @Query('allReservations')\n    async allReservationsForUser(@Context('authToken', GetUserPipe) userPromise: Promise<User>): Promise<Reservation[]> {\n        const user = await userPromise;\n        if (user) {\n            return this.reservationService.getAllReservationsForUserId(user.userId);\n        }\n        return [];\n    }\n\n    @Mutation()\n    async createReservation(@Args('reservation') reservationInput: CreateReservationInput,\n                            @Context('authToken', GetUserPipe) userPromise: Promise<User>): Promise<Reservation> {\n        const user = await userPromise;\n        if (user) {\n            return this.reservationService.createReservation(reservationInput, user.userId);\n        }\n        return undefined;\n    }\n\n    @Mutation()\n    async deleteReservation(@Args('reservationId') reservationId: string,\n                            @Context('authToken', GetUserPipe) userPromise: Promise<User>) {\n        const user = await userPromise;\n        const toDelete = await this.reservationService.getById(reservationId);\n        if (user.userId === toDelete.userId) {\n            await this.reservationService.deleteReservation(reservationId);\n            return true;\n        }\n        return false;\n    }\n}"
    },
    {
      "title": "Tests",
      "description": "",
      "code": "describe('reservations integration testing', () => {\n    let app: INestApplication;\n    let user: User;\n    let token: string;\n    let reservationId;\n\n    beforeAll(async () => {\n        ({app, user, token} = await TestUtil.setupIntegrationTest());\n    });\n\n    afterAll( async () => {\n        await TestUtil.teardownIntegrationTest(app, user.userId, token);\n    });\n\n    it('should create reservation', (done) => {\n        const date = new Date();\n        date.setFullYear(new Date().getFullYear() + 1);\n        const reservationInput: CreateReservationInput = {\n            location: TestUtil.randomString(),\n            message: TestUtil.randomString(),\n            time: date\n        };\n        TestUtil.requestWithToken(app, token)\n            .send({\n                query: `mutation ($input: CreateReservationInput!) {\n                    createReservation(reservation: $input) {\n                        id\n                        location\n                        time\n                        message\n                        userId\n                        username\n                    }\n                }`,\n                variables: {\n                    input: reservationInput\n                }\n            })\n            .expect(200)\n            .end(((err, res) => {\n                expect(err).toBeNull();\n                const reservation: Reservation = res.body.data.createReservation;\n                reservationId = reservation.id;\n                expect(reservation).toBeTruthy();\n                expect(reservation.userId).toEqual(user.userId);\n                expect(reservation.username).toEqual(user.username);\n                expect(reservation.message).toEqual(reservationInput.message);\n                expect(reservation.location).toEqual(reservationInput.location);\n                expect(reservation.time).toEqual(reservationInput.time.toISOString());\n                done();\n            }));\n    });\n\n    it('should get reservations', (done) => {\n        TestUtil.requestWithToken(app, token)\n            .send({\n                query: `query { allReservations {id} }`\n            })\n            .expect(200)\n            .end((err, res) => {\n                const reservations: Reservation[] = res.body.data.allReservations;\n                expect(err).toBeNull();\n                expect(reservations).toBeTruthy();\n                expect(reservations).toHaveLength(1);\n                expect(reservations.find(r => r.id === reservationId)).toBeTruthy();\n                done();\n            });\n    });\n\n    it('should delete reservation', (done) => {\n        TestUtil.requestWithToken(app, token)\n            .send({\n                query: `mutation ($id: String!) {deleteReservation(reservationId: $id)}`,\n                variables: {id: reservationId}\n            })\n            .expect(200)\n            .end((err, res) => {\n                expect(res.body.data.deleteReservation).toBe(true);\n                expect(err).toBeNull();\n                done();\n            });\n    });\n\n    it('should verify deleted reservation', (done) => {\n        TestUtil.requestWithToken(app, token)\n            .send({\n                query: `query { allReservations {id} }`\n            })\n            .expect(200)\n            .end((err, res) => {\n                const reservations: Reservation[] = res.body.data.allReservations;\n                expect(err).toBeNull();\n                expect(reservations).toBeTruthy();\n                expect(reservations).toHaveLength(0);\n                done();\n            });\n    });\n});"
    }
  ]
}